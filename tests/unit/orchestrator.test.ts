import { describe, it, expect, beforeEach, vi } from 'vitest';
import { generateReportNow, initializeProviders, registerCallbacks } from '../../src/stepper/orchestrator.js';
import { PromptInput, StepperCallbacks } from '../../src/types.js';

// Mock provider adapter
const mockProviderCall = vi.fn();

vi.mock('../../src/providers/hfSpace.adapter.js', () => ({
    HuggingFaceSpaceAdapter: class {
        name = 'hf-space';
        async call(input: PromptInput) {
            return mockProviderCall(input);
        }
    },
}));

describe('Orchestrator', () => {
    const testInput: PromptInput = {
        userId: 'test-user',
        commitSha: 'abc123',
        repo: 'test/repo',
        message: 'Test commit',
        files: ['test.ts'],
        components: ['test'],
        diffSummary: '+ added test',
    };

    beforeEach(() => {
        vi.clearAllMocks();
        // Initialize with minimal config
        initializeProviders([
            {
                name: 'hf-space',
                enabled: true,
                baseUrl: 'http://test.local',
                rateLimitRPS: 10,
                concurrency: 1,
                timeout: 5000,
            },
        ]);
    });

    it('should generate report using primary provider', async () => {
        const mockReport = {
            title: 'Test Report',
            summary: 'Generated by provider',
            changes: ['Change 1'],
            rationale: 'Test rationale',
            impact_and_tests: 'Test impact',
            next_steps: ['Next step'],
            tags: 'test',
        };

        mockProviderCall.mockResolvedValueOnce(mockReport);

        const result = await generateReportNow(testInput, 'test-job');

        expect(result.result).toEqual(mockReport);
        expect(result.usedProvider).toBe('hf-space');
        expect(result.fallback).toBe(false);
        expect(mockProviderCall).toHaveBeenCalledTimes(1);
    });

    it('should invoke success callback', async () => {
        const onSuccess = vi.fn();
        const callbacks: StepperCallbacks = { onSuccess };

        registerCallbacks(callbacks);

        const mockReport = {
            title: 'Test',
            summary: 'Summary',
            changes: [],
            rationale: 'Rationale',
            impact_and_tests: 'Impact',
            next_steps: [],
            tags: 'test',
        };

        mockProviderCall.mockResolvedValueOnce(mockReport);

        await generateReportNow(testInput, 'test-job');

        expect(onSuccess).toHaveBeenCalledWith(
            'test-job',
            'hf-space',
            mockReport,
            expect.objectContaining({
                timings: expect.any(Object),
            })
        );
    });

    it('should handle provider failure gracefully', async () => {
        mockProviderCall.mockRejectedValueOnce(new Error('Provider error'));

        const result = await generateReportNow(testInput, 'test-job');

        // Should fall back to template
        expect(result.fallback).toBe(true);
        expect(result.usedProvider).toBe('fallback');
        expect(result.result).toBeDefined();
        expect(result.result.title).toBeTruthy();
    });
});